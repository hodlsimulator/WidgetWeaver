//
//  RainForecastSurfaceRenderer.swift
//  WidgetWeaver
//
//  Created by . . on 12/23/25.
//
//  Forecast surface rendering core (WidgetKit-safe).
//

import Foundation
import SwiftUI

struct RainForecastSurfaceRenderer {

    let intensities: [Double]
    let certainties: [Double]
    let configuration: RainForecastSurfaceConfiguration
    let displayScale: CGFloat

    struct WetSegment {
        let range: Range<Int>
        let surfacePath: Path
        let topEdgePath: Path
    }

    func render(in context: inout GraphicsContext, size: CGSize) {
        let n = min(intensities.count, certainties.count)
        guard n > 0 else { return }

        let rect = CGRect(origin: .zero, size: size)

        if configuration.backgroundOpacity > 0 {
            var bg = Path()
            bg.addRect(rect)
            context.fill(bg, with: .color(configuration.backgroundColor.opacity(configuration.backgroundOpacity)))
        }

        let insetX = max(0, rect.width * configuration.edgeInsetFraction)
        let plotRect = rect.insetBy(dx: insetX, dy: 0)
        guard plotRect.width > 0, plotRect.height > 0 else { return }

        var baselineY = rect.minY + rect.height * configuration.baselineYFraction
        baselineY = RainSurfaceMath.alignToPixelCenter(baselineY, displayScale: displayScale)

        let maxHeight = max(0, baselineY - rect.minY)
        guard maxHeight > 0 else { return }

        let minVisibleHeight = max(0, maxHeight * configuration.minVisibleHeightFraction)
        let intensityCap = max(configuration.intensityCap, 0.000_001)

        let stepX = plotRect.width / CGFloat(n)

        // Rendering-only edge fade (start/end).
        let edgeFactors = RainSurfaceMath.edgeFactors(
            sampleCount: n,
            startEaseMinutes: configuration.startEaseMinutes,
            endFadeMinutes: configuration.endFadeMinutes,
            endFadeFloor: configuration.endFadeFloor
        )

        var wetMask = [Bool](repeating: false, count: n)
        var heights = [CGFloat](repeating: 0, count: n)
        var intensityNorm = [Double](repeating: 0, count: n)
        var certainty = [Double](repeating: 0, count: n)

        for i in 0..<n {
            let c = RainSurfaceMath.clamp01(certainties[i])
            certainty[i] = c

            let rawI = max(0.0, intensities[i])
            guard rawI > configuration.wetThreshold else { continue }

            wetMask[i] = true

            let frac = min(rawI / intensityCap, 1.0)
            let eased = pow(frac, configuration.intensityEasingPower)
            intensityNorm[i] = eased

            var h = CGFloat(eased) * maxHeight
            if h > 0 {
                h = max(h, minVisibleHeight)
            }
            heights[i] = h
        }

        if configuration.geometrySmoothingPasses > 0 {
            heights = RainSurfaceMath.smooth(heights, passes: configuration.geometrySmoothingPasses)
        }

        let wetRanges = RainSurfaceGeometry.wetRanges(from: wetMask)

        var segments: [WetSegment] = []
        segments.reserveCapacity(wetRanges.count)

        for r in wetRanges {
            let surface = RainSurfaceGeometry.makeSurfacePath(
                for: r,
                plotRect: plotRect,
                baselineY: baselineY,
                stepX: stepX,
                heights: heights
            )
            let top = RainSurfaceGeometry.makeTopEdgePath(
                for: r,
                plotRect: plotRect,
                baselineY: baselineY,
                stepX: stepX,
                heights: heights
            )
            segments.append(.init(range: r, surfacePath: surface, topEdgePath: top))
        }

        // IMPORTANT: the fill is no longer a smooth path.
        // The shape is generated by a probability mask (core + inside fade + outside fade + grain),
        // so low-chance minutes look diffuse and high-chance minutes look smooth.
        RainSurfaceDrawing.drawProbabilityMaskedSurface(
            in: &context,
            plotRect: plotRect,
            baselineY: baselineY,
            stepX: stepX,
            segments: segments,
            heights: heights,
            intensityNorm: intensityNorm,
            certainty: certainty,
            edgeFactors: edgeFactors,
            configuration: configuration,
            displayScale: displayScale
        )

        // Optional glow highlight (kept subtle and certainty-weighted).
        RainSurfaceDrawing.drawGlowIfEnabled(
            in: &context,
            plotRect: plotRect,
            baselineY: baselineY,
            stepX: stepX,
            segments: segments,
            heights: heights,
            intensityNorm: intensityNorm,
            certainty: certainty,
            edgeFactors: edgeFactors,
            configuration: configuration,
            displayScale: displayScale
        )

        RainSurfaceDrawing.drawBaseline(
            in: &context,
            plotRect: plotRect,
            baselineY: baselineY,
            configuration: configuration,
            displayScale: displayScale
        )
    }
}
